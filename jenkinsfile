pipeline {
    agent {
        kubernetes {
            yamlFile 'build-pod.yaml'
            defaultContainer 'ez-docker-helm-build'
        }
    }
    environment {
        GITHUB_CREDENTIALS = credentials('git_hub')
        DOCKER_HUB_USERNAME = credentials('docker_hub')
        DOCKER_HUB_TOKEN = credentials('docker_hub')
        TAG = 'latest'
        HELM_REPO_URL_PUSH = 'github.com/maximaxor/helmfinal.git'
        GIT_CREDENTIALS_ID = 'git_hub' // Define this variable here
    }
    stages {
        stage('Checkout') {
            steps {
                script {
                    echo "Starting checkout stage"
                    checkout([$class: 'GitSCM', branches: [[name: '*/main']], userRemoteConfigs: [[url: 'https://github.com/maximaxor/devopsfinal.git', credentialsId: 'git_hub']]])
                    echo "Checkout completed"
                }
            }
        }
        stage('Install Docker if not present') {
            steps {
                script {
                    echo "Checking Docker installation"
                    sh '''
                        if ! command -v docker &> /dev/null
                        then
                            echo "Docker not found, installing..."
                            curl -fsSL https://get.docker.com -o get-docker.sh
                            sh get-docker.sh
                            sudo usermod -aG docker $(whoami)
                        else
                            echo "Docker is already installed"
                        fi
                    '''
                    echo "Docker installation check completed"
                }
            }
        }
        stage('Install Kubectl') {
            steps {
                script {
                    echo "Installing kubectl"
                    sh '''
                        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
                        chmod +x kubectl
                        mv kubectl /usr/local/bin/
                    '''
                    echo "Kubectl installation completed"
                }
            }
        }
        stage('Set up Docker Buildx') {
            steps {
                script {
                    echo "Setting up Docker Buildx"
                    retry(3) {
                        sh 'docker run --rm --privileged multiarch/qemu-user-static --reset -p yes'
                        sh 'docker buildx create --use --name builder-$(uuidgen)'
                    }
                    echo "Docker Buildx setup completed"
                }
            }
        }
        stage('Login to DockerHub') {
            steps {
                script {
                    echo "Logging in to DockerHub"
                    withCredentials([usernamePassword(credentialsId: 'docker_hub', passwordVariable: 'DOCKER_HUB_TOKEN', usernameVariable: 'DOCKER_HUB_USERNAME')]) {
                        sh "echo \$DOCKER_HUB_TOKEN | docker login -u \$DOCKER_HUB_USERNAME --password-stdin"
                    }
                    echo "DockerHub login completed"
                }
            }
        }
        stage('Build and Run Containers') {
            steps {
                script {
                    echo "Building and running containers"
                    def services = [
                        ['name': 'license-registry', 'dockerfile': 'Dockerfile.license-registry'],
                        ['name': 'node', 'dockerfile': './node-app/Dockerfile.node'],
                        ['name': 'image-processor', 'dockerfile': 'Dockerfile.image-processor'],
                        ['name': 'frontend', 'dockerfile': 'Dockerfile.frontend'],
                        ['name': 'orchestrator', 'dockerfile': 'Dockerfile.orchestrator'],
                        ['name': 'api-gateway', 'dockerfile': 'Dockerfile.api-gateway'],
                        ['name': 'mongodb', 'dockerfile': './mongodb/Dockerfile.mongodb']
                    ]
                    services.each { service ->
                        def buildName = "builder-${service.name}"
                        echo "Building ${service.name}"
                        retry(3) {
                            sh "docker buildx create --use --name ${buildName}"
                            sh "docker build -t maximusmaxi/${service.name}:${TAG} -f ${service.dockerfile} ."
                            sh "docker buildx rm ${buildName}"
                        }
                        echo "${service.name} build completed"
                    }
                }
            }
        }
        stage('Test') {
            steps {
                container('python-test') {
                    script {
                        echo "Running tests"
                        sh 'pytest'
                        echo "Tests completed"
                    }
                }
            }
        }
        stage('Push Images to Docker Hub') {
            steps {
                script {
                    echo "Pushing images to DockerHub"
                    def services = ['license-registry', 'node', 'image-processor', 'frontend', 'orchestrator', 'api-gateway', 'mongodb']
                    withCredentials([usernamePassword(credentialsId: 'docker_hub', passwordVariable: 'DOCKER_HUB_TOKEN', usernameVariable: 'DOCKER_HUB_USERNAME')]) {
                        sh "echo \$DOCKER_HUB_TOKEN | docker login -u \$DOCKER_HUB_USERNAME --password-stdin"
                        services.each { service ->
                            retry(3) {
                                sh "DOCKER_CLI_EXPERIMENTAL=enabled docker push maximusmaxi/${service}:${TAG}"
                            }
                        }
                    }
                    echo "Images pushed to DockerHub"
                }
            }
        }
        stage('Create Merge Request') {
            when {
                not {
                    branch 'main'
                }
            }
            steps {
                withCredentials([usernamePassword(credentialsId: GIT_CREDENTIALS_ID, usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD')]) {
                    script {
                        def branchName = env.BRANCH_NAME
                        def pullRequestTitle = "Merge ${branchName} into main"
                        def pullRequestBody = "Automatically generated merge request for branch ${branchName} from Jenkins"

                        sh """
                            curl -X POST -u ${USERNAME}:${PASSWORD} \
                            -d '{ "title": "${pullRequestTitle}", "body": "${pullRequestBody}", "head": "${branchName}", "base": "main" }' \
                            https://api.github.com/repos/maximaxor/devopsfinal/pulls
                        """
                    }
                }
            }
        }
        stage('Helm') {
            when {
                branch 'main'
            }
            steps {
                script {
                    echo "Building Helm Charts"
                    sh 'helm package chart/sptr-backend --destination /home/jenkins/agent/workspace/helm-repo'
                    sh 'helm repo index --url https://maximaxor.github.io/helmfinal /home/jenkins/agent/workspace/helm-repo'
                    
                    echo "Pushing helm-repo"
                    withCredentials([usernamePassword(credentialsId: GIT_CREDENTIALS_ID, usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD')]) {
                        sh """
                            cd /home/jenkins/agent/workspace/helm-repo
                            git config --global --add safe.directory /home/jenkins/agent/workspace/helm-repo
                            git config --global user.email 'jenkins@cluster.com'
                            git config --global user.name 'Jenkins Automation'
                            git add .
                            git commit -m 'Update Helm repo' || true  // Continue even if no changes
                            git push https://${USERNAME}:${PASSWORD}@${env.HELM_REPO_URL_PUSH} main
                        """
                    }
                }
            }
        }
        stage('Cleanup') {
            steps {
                script {
                    echo "Cleaning up"
                    echo "Cleanup completed"
                }
            }
        }
    }
    post {
        always {
            echo "Pipeline finished"
        }
        failure {
            echo "Pipeline failed"
        }
    }
}
